#include <iostream> 
#include <SFML/Graphics.hpp>
#include "map.h"
#include "camera.h"

#define PI 3.141592
#define RADS PI / 180
#define GRADS 180 / PI

using namespace sf;

enum Direction
{
	DOWN,
	UP
};

enum Rotation
{
	LEFT,
	RIGHT
};

//CircleShape PointR(5);
//CircleShape PointL(5);

////////////////////////////////////////////////////КЛАСС ИГРОКА////////////////////////
class Player {
private:
	float x, y, x0, y0, w, h, w0, h0, dx, dy; //координаты игрока х и у, высота ширина, ускорение (по х и по у)
	float collision_x, collision_y, collision_z, collision_t;
	float angle = -PI / 2, speed = 0; 
	int dir = 0, rot = 0; //направление (direction) движения игрока
	bool collision = 0;
	String File; //файл с расширением
	Image image;//сфмл изображение
	Texture texture;//сфмл текстура
public:
	Sprite sprite;
	Player(String F, float x, float y, float w, float h) {  //Конструктор с параметрами(формальными) для класса Player. При создании объекта класса мы будем задавать имя файла, координату Х и У, ширину и высоту
		File = F;	//имя файла+расширение
		this->w = w; this->h = h; w0 = w; h0 = h;	//высота и ширина
		image.loadFromFile("images/" + File);//запихиваем в image наше изображение вместо File мы передадим то, что пропишем при создании объекта. В нашем случае "hero.png" и получится запись идентичная 	image.loadFromFile("images/hero/png");
		texture.loadFromImage(image);//закидываем наше изображение в текстуру
		sprite.setTexture(texture);//заливаем спрайт текстурой
		this->x = 250; this->y = 250;//координата появления спрайта
		sprite.setTextureRect(IntRect(x, y, w0, h0));  //Задаем спрайту один прямоугольник для вывода одного льва, а не кучи львов сразу. IntRect - приведение типов
	}

	void update(float time) //функция "оживления" объекта класса. update - обновление. принимает в себя время SFML , вследствие чего работает бесконечно, давая персонажу движение.
	{
		switch (dir)//реализуем поведение в зависимости от направления. (каждая цифра соответствует направлению)
		{
			case Direction::DOWN: dy = -speed * sin(angle); dx = -speed * cos(angle); 
				collision_x = (w0 / 2 * sin(angle) - h0 / 2 * cos(angle));  collision_z = (w0 / 2 * sin(angle) + h0 / 2 * cos(angle));
				collision_y = (-w0 / 2 * cos(angle) - h0 / 2 * sin(angle)); collision_t = (-w0 / 2 * cos(angle) + h0 / 2 * sin(angle)); break;
			case Direction::UP:	  dy = speed * sin(angle); dx = speed * cos(angle);	  
				collision_x = (w0 / 2 * sin(angle) + h0 / 2 * cos(angle));  collision_z = (w0 / 2 * sin(angle) - h0 / 2 * cos(angle));
				collision_y = (-w0 / 2 * cos(angle) + h0 / 2 * sin(angle)); collision_t = (-w0 / 2 * cos(angle) - h0 / 2 * sin(angle)); break;
		}
		if (dy == 0 || dx == 0) {
			switch (rot)//реализуем поведение в зависимости от направления. (каждая цифра соответствует направлению)
			{
			case Rotation::LEFT:  collision_x = (w0 / 2 * sin(angle) + h0 / 2 * cos(angle));  collision_z = (w0 / 2 * sin(angle) + h0 / 2 * cos(angle));
								  collision_y = (-w0 / 2 * cos(angle) + h0 / 2 * sin(angle)); collision_t = (-w0 / 2 * cos(angle) + h0 / 2 * sin(angle)); break;
			case Rotation::RIGHT: collision_x = (-w0 / 2 * sin(angle) + h0 / 2 * cos(angle)); collision_z = (-w0 / 2 * sin(angle) + h0 / 2 * cos(angle));
								  collision_y = (w0 / 2 * cos(angle) + h0 / 2 * sin(angle));  collision_t = (w0 / 2 * cos(angle) + h0 / 2 * sin(angle));  break;
			}
		}
		x0 = x;
		y0 = y;
		collision = false;
		x += dx * time;//то движение из прошлого урока. наше ускорение на время получаем смещение координат и как следствие движение
		y += dy * time;//аналогично по игреку
		/*w = w0 * abs(sin(angle)) + h0 * abs(cos(angle));
		h = w0 * abs(cos(angle)) + h0 * abs(sin(angle));*/
		speed = 0;//зануляем скорость, чтобы персонаж остановился.
		sprite.setPosition(x, y); //выводим спрайт в позицию x y , посередине. бесконечно выводим в этой функции, иначе бы наш спрайт стоял на месте.
		sprite.setOrigin(w0 / 2, h0 / 2);


		/*std::cout << "\ndx = " << dx << std::endl;
		std::cout << "dy = " << dy << std::endl;
		std::cout << "angle = " << angle << std::endl;*/

		//if (dy > 0) {//если мы шли вниз,
		//	collision_y = 0;
		//	collision_t = -(w0 / 2 * cos(angle) + h0 / 2 * sin(angle));
		//}
		//if (dy < 0) {
		//	collision_y = 0;
		//	collision_t = (-w0 / 2 * cos(angle) + h0 / 2 * sin(angle));
		//}
		//if (dx > 0) {
		//	collision_x = 0;
		//	collision_z = (-w0 / 2 * sin(angle) + h0 / 2 * cos(angle));
		//}
		//if (dx < 0) {
		//	collision_x = 0;
		//	collision_z = -(w0 / 2 * sin(angle) + h0 / 2 * cos(angle));
		//}

		
		if (TileMap[int( (y - collision_t) / 32)][int( (x - collision_z) / 32)] == '0' || 
			TileMap[int( (y + collision_y) / 32)][int( (x + collision_x) / 32)] == '0' ||
			TileMap[int( (y + collision_y/2 - collision_t/2) / 32)][int((x + collision_x / 2 - collision_z / 2) / 32)] == '0'   ||
			TileMap[int((y - collision_t) / 32)][int((x - collision_z) / 32)] == 's'   ||
			TileMap[int((y + collision_y / 2 - collision_t / 2) / 32)][int((x + collision_x / 2 - collision_z / 2) / 32)] == 's' ||
			TileMap[int((y + collision_y) / 32)][int((x + collision_x) / 32)] == 's')
			//(x + collision_x / 2 - collision_z / 2, y + collision_y / 2 - collision_t / 2)
		{
			std::cout << "\ndy = " << dy << std::endl;
			std::cout << "dx = " << dx << std::endl;
			std::cout << "\nW = " << w << std::endl;
			std::cout << "H = " << h << std::endl;

			x = x0;
			y = y0;
			collision = true;
		}
	}

	float getDirection() { return dir; }		void setDirection(float dir) { this->dir = dir; }
	float getRotation() { return rot; }			void setRotation(float rot) { this->rot = rot; }
	float getSpeed() { return speed; }			void setSpeed(float speed) { this->speed = speed; }
	float getAngle() { return angle; }			void setAngle(float angle) { this->angle = angle; }
	float getplayercoordinateX() { return x; }	void setplayercoordinateX(float x) { this->x = x; }
	float getplayercoordinateY() { return y; }	void setplayercoordinateY(float y) { this->y = y; }
	float getplayerWidth()  { return w0; }		void setplayerWidth(float w0)  { this->w0 = w0; }
	float getplayerHeight() { return h0; }		void setplayerHeight(float h0) { this->h0 = h0; }
	bool  getCollision() { return collision; }
};

int main()
{
	Clock clock;
	Image map_image;
	Texture map;
	Sprite s_map;
	map_image.loadFromFile("images/map.png");
	map.loadFromImage(map_image);
	s_map.setTexture(map);
	RenderWindow window(VideoMode(1370, 600), "Game");
	Player actor("tiger2_body.png", 0, 0, 65, 125);//создаем объект actor класса player,задаем "hero.png" как имя файла+расширение, далее координата Х,У, ширина, высота.
	Player Gun("tiger2_gun.png", 0, 0, 45, 215);
	camera.reset(FloatRect(0, 0, 1370, 600));//размер "вида" камеры при создании объекта вида камеры. (потом можем менять как хотим) Что то типа инициализации.

	while (window.isOpen())
	{
		float time = clock.getElapsedTime().asMicroseconds();
		clock.restart();
		time = time / 800;

		Vector2i MousePixelPos = Mouse::getPosition(window);//забираем коорд курсора
		Vector2f MousePos = window.mapPixelToCoords(MousePixelPos);//переводим их в игровые (уходим от коорд окна)
		float dX = MousePos.x - actor.getplayercoordinateX();//вектор , колинеарный прямой, которая пересекает спрайт и курсор
		float dY = MousePos.y - actor.getplayercoordinateY();//он же, координата y
		float rotation = (atan2(dY, dX)) * GRADS;//получаем угол в радианах и переводим его в градусы
		Gun.sprite.setOrigin(Gun.getplayerWidth() / 2, Gun.getplayerHeight() / 2);
		Gun.sprite.setRotation(rotation + 90);//поворачиваем спрайт на эти градусы

		Event event;
		while (window.pollEvent(event))
		{
			if (event.type == Event::Closed)
				window.close();
		}
		///////////////////////////////////////////Управление персонажем////////////////////////////////////////////////////////////////////////
		if ((Keyboard::isKeyPressed(Keyboard::Left) || (Keyboard::isKeyPressed(Keyboard::A)))) {
			if (actor.getCollision() == false || ((Keyboard::isKeyPressed(Keyboard::S) || (Keyboard::isKeyPressed(Keyboard::W)))) ) {
				actor.sprite.setRotation(actor.sprite.getRotation() - 0.1);
				actor.setAngle(actor.getAngle() - 0.1 * RADS);
			}
			actor.setRotation(LEFT);
		}
		if ((Keyboard::isKeyPressed(Keyboard::Right) || (Keyboard::isKeyPressed(Keyboard::D)))) {
			if (actor.getCollision() == false || ((Keyboard::isKeyPressed(Keyboard::S) || (Keyboard::isKeyPressed(Keyboard::W)))) ) {
				actor.sprite.setRotation(actor.sprite.getRotation() + 0.1);
				actor.setAngle(actor.getAngle() + 0.1 * RADS);
			}
			actor.setRotation(RIGHT);
		}
		if ((Keyboard::isKeyPressed(Keyboard::Up) || (Keyboard::isKeyPressed(Keyboard::W)))) {
			actor.setDirection(UP);
			actor.setSpeed(0.2);
		}
		if ((Keyboard::isKeyPressed(Keyboard::Down) || (Keyboard::isKeyPressed(Keyboard::S)))) {
			actor.setDirection(DOWN);
			actor.setSpeed(0.2);
		}

		getPlayerCoordinateForCamera(actor.getplayercoordinateX(), actor.getplayercoordinateY() );
		actor.update(time);		//оживляем объект p класса Player с помощью времени sfml, передавая время в качестве параметра функции update. благодаря этому персонаж может двигаться
		Gun.sprite.setPosition(actor.getplayercoordinateX(), actor.getplayercoordinateY() );

		window.setView(camera);	//оживляем камеру в окне sfml
		window.clear(Color(128, 106, 89));

		/////////////////////////////Рисуем карту/////////////////////
		for (int y = 0; y < HEIGHT_MAP; y++)
			for (int x = 0; x < WIDTH_MAP; x++)
			{
				if (TileMap[y][x] == ' ')  s_map.setTextureRect(IntRect(0, 0, 32, 32)); //если встретили символ пробел, то рисуем 1й квадратик
				if (TileMap[y][x] == 's')  s_map.setTextureRect(IntRect(32, 0, 32, 32));//если встретили символ s, то рисуем 2й квадратик
				if ((TileMap[y][x] == '0')) s_map.setTextureRect(IntRect(64, 0, 32, 32));//если встретили символ 0, то рисуем 3й квадратик
				s_map.setPosition(x * 32, y * 32);//по сути раскидывает квадратики, превращая в карту. то есть задает каждому из них позицию. если убрать, то вся карта нарисуется в одном квадрате 32*32 и мы увидим один квадрат
				window.draw(s_map);//рисуем квадратики на экран
			}

		window.draw(actor.sprite);
		window.draw(Gun.sprite);
		window.display();
	}
	return 0;
}