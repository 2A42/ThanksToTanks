#include <iostream> 
#include <SFML/Graphics.hpp>
#include "map.h"
#include "camera.h"

#define PI 3.141592
#define RADS PI / 180
#define GRADS 180 / PI

using namespace sf;

enum Direction
{
	DOWN,
	UP
};

enum Rotation
{
	LEFT,
	RIGHT
};

//CircleShape PointR(5);
//CircleShape PointL(5);

////////////////////////////////////////////////////КЛАСС ИГРОКА////////////////////////
class Player {
private:
	float x, y, x0, y0, w, h, dx, dy; //координаты игрока х и у, высота ширина, ускорение (по х и по у)
	float collisionPoint_X1, collisionPoint_Y1, collisionPoint_X2, collisionPoint_Y2;
	float whAngle_x1, whAngle_y1, whAngle_x2, whAngle_y2, whAngle_x3, whAngle_y3;
	float angle = -PI / 2, speed = 0; 
	int dir = 0, rot = 0; //направление (direction) движения игрока
	bool collision = 0;
	String File; //файл с расширением
	Image image;//сфмл изображение
	Texture texture;//сфмл текстура
public:
	Sprite sprite;
	Player(String F, float x, float y, float w, float h) {  //Конструктор с параметрами(формальными) для класса Player. При создании объекта класса мы будем задавать имя файла, координату Х и У, ширину и высоту
		File = F;	//имя файла+расширение
		this->w = w; this->h = h;	//высота и ширина
		image.loadFromFile("images/" + File);//запихиваем в image наше изображение вместо File мы передадим то, что пропишем при создании объекта. В нашем случае "hero.png" и получится запись идентичная 	image.loadFromFile("images/hero/png");
		texture.loadFromImage(image);//закидываем наше изображение в текстуру
		sprite.setTexture(texture);//заливаем спрайт текстурой
		this->x = 250; this->y = 250;//координата появления спрайта
		sprite.setTextureRect(IntRect(x, y, w, h));  //Задаем спрайту один прямоугольник для вывода одного льва, а не кучи львов сразу. IntRect - приведение типов
	}

	void interactionWithMap() {
		if (TileMap[int((y - collisionPoint_Y2) / 32)][int((x - collisionPoint_X2) / 32)] == '0' ||
			TileMap[int((y + collisionPoint_Y1) / 32)][int((x + collisionPoint_X1) / 32)] == '0' ||
			TileMap[int((y - collisionPoint_Y2) / 32)][int((x - collisionPoint_X2) / 32)] == 's' ||
			TileMap[int((y + collisionPoint_Y1) / 32)][int((x + collisionPoint_X1) / 32)] == 's' ||
			TileMap[int((y + collisionPoint_Y1 / 2 - collisionPoint_Y2 / 2) / 32)][int((x + collisionPoint_X1 / 2 - collisionPoint_X2 / 2) / 32)] == '0' ||
			TileMap[int((y + collisionPoint_Y1 / 2 - collisionPoint_Y2 / 2) / 32)][int((x + collisionPoint_X1 / 2 - collisionPoint_X2 / 2) / 32)] == 's')
		{
			x = x0;
			y = y0;
			collision = true;
		}
	}

	void update(float time) //функция "оживления" объекта класса. update - обновление. принимает в себя время SFML , вследствие чего работает бесконечно, давая персонажу движение.
	{
		whAngle_x1 = (w / 2 * sin(angle) - h / 2 * cos(angle));		whAngle_y1 = (-w / 2 * cos(angle) - h / 2 * sin(angle));
		whAngle_x2 = (w / 2 * sin(angle) + h / 2 * cos(angle));		whAngle_y2 = (-w / 2 * cos(angle) + h / 2 * sin(angle));
		whAngle_x3 = (-w / 2 * sin(angle) + h / 2 * cos(angle));	whAngle_y3 = (w / 2 * cos(angle) + h / 2 * sin(angle));
		switch (dir)
		{
			case Direction::DOWN: dy = -speed * sin(angle); dx = -speed * cos(angle);
				collisionPoint_X1 = whAngle_x1;  collisionPoint_X2 = whAngle_x2;
				collisionPoint_Y1 = whAngle_y1;  collisionPoint_Y2 = whAngle_y2; break;
			case Direction::UP:	  dy = speed * sin(angle); dx = speed * cos(angle);
				collisionPoint_X1 = whAngle_x2;  collisionPoint_X2 = whAngle_x1;
				collisionPoint_Y1 = whAngle_y2;  collisionPoint_Y2 = whAngle_y1; break;
		}
		if (dy == 0 || dx == 0) {
			switch (rot) {
			case Rotation::LEFT:
				collisionPoint_X1 = whAngle_x2;  collisionPoint_X2 = whAngle_x2;
				collisionPoint_Y1 = whAngle_y2;  collisionPoint_Y2 = whAngle_y2; break;
			case Rotation::RIGHT:
				collisionPoint_X1 = whAngle_x3;  collisionPoint_X2 = whAngle_x3;
				collisionPoint_Y1 = whAngle_y3;  collisionPoint_Y2 = whAngle_y3; break;
			}
		}
		x0 = x;
		y0 = y;
		collision = false;
		x += dx * time;//то движение из прошлого урока. наше ускорение на время получаем смещение координат и как следствие движение
		y += dy * time;//аналогично по игреку
		speed = 0;//зануляем скорость, чтобы персонаж остановился.
		sprite.setPosition(x, y); //выводим спрайт в позицию x y , посередине. бесконечно выводим в этой функции, иначе бы наш спрайт стоял на месте.
		sprite.setOrigin(w / 2, h / 2);
		/*w = w0 * abs(sin(angle)) + h0 * abs(cos(angle));
		h = w0 * abs(cos(angle)) + h0 * abs(sin(angle));*/
		interactionWithMap();
	}

	float getDirection() { return dir; }		void setDirection(float dir) { this->dir = dir; }
	float getRotation() { return rot; }			void setRotation(float rot) { this->rot = rot; }
	float getSpeed() { return speed; }			void setSpeed(float speed) { this->speed = speed; }
	float getAngle() { return angle; }			void setAngle(float angle) { this->angle = angle; }
	float getplayercoordinateX() { return x; }	void setplayercoordinateX(float x) { this->x = x; }
	float getplayercoordinateY() { return y; }	void setplayercoordinateY(float y) { this->y = y; }
	float getplayerWidth()  { return w; }		void setplayerWidth(float w)  { this->w = w; }
	float getplayerHeight() { return h; }		void setplayerHeight(float h) { this->h = h; }
	bool  getCollision() { return collision; }
};

int main()
{
	Clock clock;
	Image map_image;
	Texture map;
	Sprite s_map;
	map_image.loadFromFile("images/map.png");
	map.loadFromImage(map_image);
	s_map.setTexture(map);
	RenderWindow window(VideoMode(1370, 600), "Game");
	Player Body("tiger2_body.png", 0, 0, 65, 125);//создаем объект actor класса player,задаем "hero.png" как имя файла+расширение, далее координата Х,У, ширина, высота.
	Player Gun("tiger2_gun.png", 0, 0, 45, 215);
	camera.reset(FloatRect(0, 0, 1370, 600));//размер "вида" камеры при создании объекта вида камеры. (потом можем менять как хотим) Что то типа инициализации.

	while (window.isOpen())
	{
		float time = clock.getElapsedTime().asMicroseconds();
		clock.restart();
		time = time / 800;

		Vector2i MousePixelPos = Mouse::getPosition(window);//забираем коорд курсора
		Vector2f MousePos = window.mapPixelToCoords(MousePixelPos);//переводим их в игровые (уходим от коорд окна)
		float dX = MousePos.x - Body.getplayercoordinateX();//вектор , колинеарный прямой, которая пересекает спрайт и курсор
		float dY = MousePos.y - Body.getplayercoordinateY();//он же, координата y
		float rotation = (atan2(dY, dX)) * GRADS;//получаем угол в радианах и переводим его в градусы
		Gun.sprite.setOrigin(Gun.getplayerWidth() / 2, Gun.getplayerHeight() / 2);
		Gun.sprite.setRotation(rotation + 90);//поворачиваем спрайт на эти градусы

		Event event;
		while (window.pollEvent(event))
		{
			if (event.type == Event::Closed)
				window.close();
		}
		///////////////////////////////////////////Управление персонажем////////////////////////////////////////////////////////////////////////
		if ((Keyboard::isKeyPressed(Keyboard::Left) || (Keyboard::isKeyPressed(Keyboard::A)))) {
			if (Body.getCollision() == false || ((Keyboard::isKeyPressed(Keyboard::S) || (Keyboard::isKeyPressed(Keyboard::W)))) ) {
				Body.sprite.setRotation(Body.sprite.getRotation() - 0.1);
				Body.setAngle(Body.getAngle() - 0.1 * RADS); }
			Body.setRotation(LEFT);
		}
		if ((Keyboard::isKeyPressed(Keyboard::Right) || (Keyboard::isKeyPressed(Keyboard::D)))) {
			if (Body.getCollision() == false || ((Keyboard::isKeyPressed(Keyboard::S) || (Keyboard::isKeyPressed(Keyboard::W)))) ) {
				Body.sprite.setRotation(Body.sprite.getRotation() + 0.1);
				Body.setAngle(Body.getAngle() + 0.1 * RADS); }
			Body.setRotation(RIGHT);
		}
		if ((Keyboard::isKeyPressed(Keyboard::Up) || (Keyboard::isKeyPressed(Keyboard::W)))) {
			Body.setDirection(UP);
			Body.setSpeed(0.2);
		}
		if ((Keyboard::isKeyPressed(Keyboard::Down) || (Keyboard::isKeyPressed(Keyboard::S)))) {
			Body.setDirection(DOWN);
			Body.setSpeed(0.2);
		}

		getPlayerCoordinateForCamera(Body.getplayercoordinateX(), Body.getplayercoordinateY() );
		Body.update(time);		//оживляем объект p класса Player с помощью времени sfml, передавая время в качестве параметра функции update. благодаря этому персонаж может двигаться
		Gun.sprite.setPosition(Body.getplayercoordinateX(), Body.getplayercoordinateY() );

		window.setView(camera);	//оживляем камеру в окне sfml
		window.clear(Color(128, 106, 89));

		/////////////////////////////Рисуем карту/////////////////////
		for (int y = 0; y < HEIGHT_MAP; y++)
			for (int x = 0; x < WIDTH_MAP; x++)
			{
				if (TileMap[y][x] == ' ')  s_map.setTextureRect(IntRect(0, 0, 32, 32)); //если встретили символ пробел, то рисуем 1й квадратик
				if (TileMap[y][x] == 's')  s_map.setTextureRect(IntRect(32, 0, 32, 32));//если встретили символ s, то рисуем 2й квадратик
				if ((TileMap[y][x] == '0')) s_map.setTextureRect(IntRect(64, 0, 32, 32));//если встретили символ 0, то рисуем 3й квадратик
				s_map.setPosition(x * 32, y * 32);//по сути раскидывает квадратики, превращая в карту. то есть задает каждому из них позицию. если убрать, то вся карта нарисуется в одном квадрате 32*32 и мы увидим один квадрат
				window.draw(s_map);//рисуем квадратики на экран
			}

		window.draw(Body.sprite);
		window.draw(Gun.sprite);
		window.display();
	}
	return 0;
}