#include <iostream> 
#include <SFML/Graphics.hpp>
#include "map.h"
#include "camera.h"

#define PI 3.141592
#define RADS PI / 180
#define GRADS 180 / PI

using namespace sf;

enum Direction
{
	DOWN,
	UP
};

////////////////////////////////////////////////////КЛАСС ИГРОКА////////////////////////
class Player {
private:
	float x, y, x0, y0, w, h, w0, h0, dx, dy; //координаты игрока х и у, высота ширина, ускорение (по х и по у)
	float collision_w, collision_h;
	float angle = -PI / 2, speed = 0; 
	int dir = 0; //направление (direction) движения игрока
	String File; //файл с расширением
	Image image;//сфмл изображение
	Texture texture;//сфмл текстура
public:
	Sprite sprite;
	Player(String F, float x, float y, float w, float h) {  //Конструктор с параметрами(формальными) для класса Player. При создании объекта класса мы будем задавать имя файла, координату Х и У, ширину и высоту
		File = F;	//имя файла+расширение
		this->w = w; this->h = h; w0 = w; h0 = h;	//высота и ширина
		image.loadFromFile("images/" + File);//запихиваем в image наше изображение вместо File мы передадим то, что пропишем при создании объекта. В нашем случае "hero.png" и получится запись идентичная 	image.loadFromFile("images/hero/png");
		texture.loadFromImage(image);//закидываем наше изображение в текстуру
		sprite.setTexture(texture);//заливаем спрайт текстурой
		this->x = 250; this->y = 250;//координата появления спрайта
		sprite.setTextureRect(IntRect(x, y, w0, h0));  //Задаем спрайту один прямоугольник для вывода одного льва, а не кучи львов сразу. IntRect - приведение типов
	}

	void update(float time) //функция "оживления" объекта класса. update - обновление. принимает в себя время SFML , вследствие чего работает бесконечно, давая персонажу движение.
	{
		switch (dir)//реализуем поведение в зависимости от направления. (каждая цифра соответствует направлению)
		{
			case Direction::DOWN: dy = -speed * sin(angle); dx = -speed * cos(angle); break;
			case Direction::UP:	  dy = speed * sin(angle); dx = speed * cos(angle);	  break;
		}
		x0 = x;
		y0 = y;
		x += dx * time;//то движение из прошлого урока. наше ускорение на время получаем смещение координат и как следствие движение
		y += dy * time;//аналогично по игреку
		w = w0 * abs(sin(angle)) + h0 * abs(cos(angle));
		h = w0 * abs(cos(angle)) + h0 * abs(sin(angle));
		speed = 0;//зануляем скорость, чтобы персонаж остановился.
		sprite.setPosition(x, y); //выводим спрайт в позицию x y , посередине. бесконечно выводим в этой функции, иначе бы наш спрайт стоял на месте.
		sprite.setOrigin(w0 / 2, h0 / 2);

		/*std::cout << "\nW = " << w << std::endl;
		std::cout << "H = " << h << std::endl;
		std::cout << "angle = " << angle << std::endl;*/

		if (dy >= 0)//если мы шли вниз,
			collision_h = h;
		if (dy < 0)
			collision_h = -h;
		if (dx >= 0)
			collision_w = w;
		if (dx < 0)
			collision_w = -w;

		//void interactionWithMap() {
		//		for (int i = y / 32; i < (y + h) / 32; i++)		//проходимся по тайликам, контактирующим с игроком, то есть по всем квадратикам размера 32*32, которые мы окрашивали в 9 уроке. про условия читайте ниже.
		//			for (int j = x / 32; j < (x + w) / 32; j++)	//икс делим на 32, тем самым получаем левый квадратик, с которым персонаж соприкасается. (он ведь больше размера 32*32, поэтому может одновременно стоять на нескольких квадратах). А j<(x + w) / 32 - условие ограничения координат по иксу. то есть координата самого правого квадрата, который соприкасается с персонажем. таким образом идем в цикле слева направо по иксу, проходя по от левого квадрата (соприкасающегося с героем), до правого квадрата (соприкасающегося с героем)
		//			{
		//				if (TileMap[i][j] == '0' || TileMap[i][j] == 's')//если наш квадратик соответствует символу 0 (стена), то проверяем "направление скорости" персонажа:
		//				{
		//					x = x0;
		//					y = y0;
		//						if (dy > 0)//если мы шли вниз,
		//							y = y0 - h;//то стопорим координату игрек персонажа. сначала получаем координату нашего квадратика на карте(стены) и затем вычитаем из высоты спрайта персонажа.
		//						if (dy < 0)
		//							y = y0 + 32;//аналогично с ходьбой вверх. dy<0, значит мы идем вверх (вспоминаем координаты паинта)
		//						if (dx > 0)
		//							x = x0 - w;//если идем вправо, то координата Х равна стена (символ 0) минус ширина персонажа
		//						if (dx < 0)
		//							x = x0 + 32;//аналогично идем влево
		//				}
		//			}
		//	}
		
		if (TileMap[int( (y + collision_h/2) / 32)][int( (x + collision_w/2) / 32)] == '0' || 
			TileMap[int( (y + collision_h/2) / 32)][int( (x + collision_w/2) / 32)] == 's')
		{
			std::cout << "\nY = " << int((y + collision_h / 2) / 32) << std::endl;
			std::cout << "X = " << int((x + collision_w / 2) / 32) << std::endl;
			std::cout << "angle = " << angle << std::endl;

			x = x0;
			y = y0;
		}
	}

	float getDirection() { return dir; }		void setDirection(float dir) { this->dir = dir; }
	float getSpeed() { return speed; }			void setSpeed(float speed) { this->speed = speed; }
	float getAngle() { return angle; }			void setAngle(float angle) { this->angle = angle; }
	float getplayercoordinateX() { return x; }	void setplayercoordinateX(float x) { this->x = x; }
	float getplayercoordinateY() { return y; }	void setplayercoordinateY(float y) { this->y = y; }
	float getplayerWidth()  { return w0; }		void setplayerWidth(float w0)  { this->w0 = w0; }
	float getplayerHeight() { return h0; }		void setplayerHeight(float h0) { this->h0 = h0; }
};

int main()
{
	Clock clock;
	Image map_image;
	Texture map;
	Sprite s_map;
	map_image.loadFromFile("images/map.png");
	map.loadFromImage(map_image);
	s_map.setTexture(map);
	RenderWindow window(VideoMode(1370, 600), "Game");
	Player actor("tiger2_body.png", 0, 0, 65, 125);//создаем объект actor класса player,задаем "hero.png" как имя файла+расширение, далее координата Х,У, ширина, высота.
	Player Gun("tiger2_gun.png", 0, 0, 45, 215);
	camera.reset(FloatRect(0, 0, 1370, 600));//размер "вида" камеры при создании объекта вида камеры. (потом можем менять как хотим) Что то типа инициализации.

	while (window.isOpen())
	{
		float time = clock.getElapsedTime().asMicroseconds();
		clock.restart();
		time = time / 800;

		Vector2i MousePixelPos = Mouse::getPosition(window);//забираем коорд курсора
		Vector2f MousePos = window.mapPixelToCoords(MousePixelPos);//переводим их в игровые (уходим от коорд окна)
		float dX = MousePos.x - actor.getplayercoordinateX();//вектор , колинеарный прямой, которая пересекает спрайт и курсор
		float dY = MousePos.y - actor.getplayercoordinateY();//он же, координата y
		float rotation = (atan2(dY, dX)) * GRADS;//получаем угол в радианах и переводим его в градусы
		Gun.sprite.setOrigin(Gun.getplayerWidth() / 2, Gun.getplayerHeight() / 2);
		Gun.sprite.setRotation(rotation + 90);//поворачиваем спрайт на эти градусы

		Event event;
		while (window.pollEvent(event))
		{
			if (event.type == Event::Closed)
				window.close();
		}
		///////////////////////////////////////////Управление персонажем////////////////////////////////////////////////////////////////////////
		if ((Keyboard::isKeyPressed(Keyboard::Left) || (Keyboard::isKeyPressed(Keyboard::A)))) {
			actor.sprite.setRotation(actor.sprite.getRotation() - 0.1);
			actor.setAngle(actor.getAngle() - 0.1 * RADS);
		}
		if ((Keyboard::isKeyPressed(Keyboard::Right) || (Keyboard::isKeyPressed(Keyboard::D)))) {
			actor.sprite.setRotation(actor.sprite.getRotation() + 0.1);
			actor.setAngle(actor.getAngle() + 0.1 * RADS);
		}
		if ((Keyboard::isKeyPressed(Keyboard::Up) || (Keyboard::isKeyPressed(Keyboard::W)))) {
			actor.setDirection(UP);
			actor.setSpeed(0.2);
		}
		if ((Keyboard::isKeyPressed(Keyboard::Down) || (Keyboard::isKeyPressed(Keyboard::S)))) {
			actor.setDirection(DOWN);
			actor.setSpeed(0.2);
		}

		getPlayerCoordinateForCamera(actor.getplayercoordinateX(), actor.getplayercoordinateY() );
		actor.update(time);		//оживляем объект p класса Player с помощью времени sfml, передавая время в качестве параметра функции update. благодаря этому персонаж может двигаться
		Gun.sprite.setPosition(actor.getplayercoordinateX(), actor.getplayercoordinateY() );

		window.setView(camera);	//оживляем камеру в окне sfml
		window.clear(Color(128, 106, 89));

		/////////////////////////////Рисуем карту/////////////////////
		for (int y = 0; y < HEIGHT_MAP; y++)
			for (int x = 0; x < WIDTH_MAP; x++)
			{
				if (TileMap[y][x] == ' ')  s_map.setTextureRect(IntRect(0, 0, 32, 32)); //если встретили символ пробел, то рисуем 1й квадратик
				if (TileMap[y][x] == 's')  s_map.setTextureRect(IntRect(32, 0, 32, 32));//если встретили символ s, то рисуем 2й квадратик
				if ((TileMap[y][x] == '0')) s_map.setTextureRect(IntRect(64, 0, 32, 32));//если встретили символ 0, то рисуем 3й квадратик
				s_map.setPosition(x * 32, y * 32);//по сути раскидывает квадратики, превращая в карту. то есть задает каждому из них позицию. если убрать, то вся карта нарисуется в одном квадрате 32*32 и мы увидим один квадрат
				window.draw(s_map);//рисуем квадратики на экран
			}

		window.draw(actor.sprite);
		window.draw(Gun.sprite);
		window.display();
	}
	return 0;
}