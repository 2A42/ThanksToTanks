#include <iostream> 
#include <SFML/Graphics.hpp>
#include "camera.h"
#include <sstream>
#include "iostream"
#include "level.h"
#include <vector>
#include <list>
#include "TinyXML/tinyxml.h"

#define PI 3.141592
#define RADS PI / 180
#define GRADS 180 / PI

using namespace sf;

enum Direction
{
	DOWN,
	UP
};

enum Rotation
{
	LEFT,
	RIGHT
};

//CircleShape PointR(5);
//CircleShape PointL(5);

class Entity {
protected:
	std::vector<Object> obj;//вектор объектов карты
	int direction = 0, rotation = 0;
	float dx, dy, x, y, x0, y0, w, h, health, speed = 0, angle = -PI / 2;
	float collisionPoint_X1, collisionPoint_Y1, collisionPoint_X2, collisionPoint_Y2;
	float whAngle_x1, whAngle_y1, whAngle_x2, whAngle_y2, whAngle_x3, whAngle_y3;
	bool life, collision = false;
	Texture texture;
	String name;	//враги могут быть разные, мы не будем делать другой класс для врага.всего лишь различим врагов по имени и дадим каждому свое действие в update в зависимости от имени
	
	////////////////////////////////////////Some bullshit stuff for collision(!badcode!)
	FloatRect getPointLeft() {
		return FloatRect(x + collisionPoint_X1, y + collisionPoint_Y1, 1, 1);
	}
	FloatRect getPointRight() {
		return FloatRect(x - collisionPoint_X2, y - collisionPoint_Y2, 1, 1);
	}
	FloatRect getPointMiddle() {
		return FloatRect((x + collisionPoint_X1 / 2 - collisionPoint_X2 / 2), (y + collisionPoint_Y1 / 2 - collisionPoint_Y2 / 2), 1, 1);
	}
	////////////////////////////////////////Sorry for that
public:
	Sprite sprite;
	Entity(Image& image, float X, float Y, int W, int H, String Name) {
		x = X; y = Y; w = W; h = H; name = Name;
		speed = 0; health = 100; dx = 0; dy = 0;
		texture.loadFromImage(image);
		sprite.setTexture(texture);
		sprite.setOrigin(w / 2, h / 2);
		life = true;
	}
};

class Player : public Entity {
public:
	Player(Image& image, Level& lev, float X, float Y, int W, int H, String Name) :Entity(image, X, Y, W, H, Name) {
		obj = lev.GetAllObjects();
		if (name == "Player1") {
			sprite.setTextureRect(IntRect(0, 0, w, h));
		}
	}

	void Control() {
		if ((Keyboard::isKeyPressed(Keyboard::Left) || (Keyboard::isKeyPressed(Keyboard::A)))) {
			if (collision == false || ((Keyboard::isKeyPressed(Keyboard::S) || (Keyboard::isKeyPressed(Keyboard::W))))) {
				sprite.setRotation(sprite.getRotation() - 0.5);
				angle = angle - 0.5 * RADS;
			}
			rotation = LEFT;
		}
		if ((Keyboard::isKeyPressed(Keyboard::Right) || (Keyboard::isKeyPressed(Keyboard::D)))) {
			if (collision == false || ((Keyboard::isKeyPressed(Keyboard::S) || (Keyboard::isKeyPressed(Keyboard::W))))) {
				sprite.setRotation(sprite.getRotation() + 0.5);
				angle = angle + 0.5 * RADS;
			}
			rotation = RIGHT;
		}
		if ((Keyboard::isKeyPressed(Keyboard::Up) || (Keyboard::isKeyPressed(Keyboard::W)))) {
			direction = UP;
			speed = 0.2;
		}
		if ((Keyboard::isKeyPressed(Keyboard::Down) || (Keyboard::isKeyPressed(Keyboard::S)))) {
			direction = DOWN;
			speed = 0.2;
		}
	}

	void checkCollisionWithMap() {
		/*if (TileMap[int((y - collisionPoint_Y2) / 32)][int((x - collisionPoint_X2) / 32)] == '0' ||
			TileMap[int((y + collisionPoint_Y1) / 32)][int((x + collisionPoint_X1) / 32)] == '0' ||
			TileMap[int((y - collisionPoint_Y2) / 32)][int((x - collisionPoint_X2) / 32)] == 's' ||
			TileMap[int((y + collisionPoint_Y1) / 32)][int((x + collisionPoint_X1) / 32)] == 's' ||
			TileMap[int((y + collisionPoint_Y1 / 2 - collisionPoint_Y2 / 2) / 32)][int((x + collisionPoint_X1 / 2 - collisionPoint_X2 / 2) / 32)] == '0' ||
			TileMap[int((y + collisionPoint_Y1 / 2 - collisionPoint_Y2 / 2) / 32)][int((x + collisionPoint_X1 / 2 - collisionPoint_X2 / 2) / 32)] == 's')
		{
			x = x0;
			y = y0;
			collision = true;
		}*/
		for (int i = 0; i < obj.size(); i++)//проходимся по объектам
			if (getPointLeft().intersects(obj[i].rect)  ||
				getPointRight().intersects(obj[i].rect) ||
				getPointMiddle().intersects(obj[i].rect))//проверяем пересечение игрока с объектом
			{
				//if (obj[i].name == "wall")//если встретили препятствие
				//{
				//	x = x0;
				//	y = y0;
				//	collision = true;
				//}
				x = x0;
				y = y0;
				collision = true;
			}
	}

	void update(float time) //функция "оживления" объекта класса. update - обновление. принимает в себя время SFML , вследствие чего работает бесконечно, давая персонажу движение.
	{
		////////////////////////////////////Some stupid math(!badcode!)
		whAngle_x1 = (w / 2 * sin(angle) - h / 2 * cos(angle));		whAngle_y1 = (-w / 2 * cos(angle) - h / 2 * sin(angle));
		whAngle_x2 = (w / 2 * sin(angle) + h / 2 * cos(angle));		whAngle_y2 = (-w / 2 * cos(angle) + h / 2 * sin(angle));
		whAngle_x3 = (-w / 2 * sin(angle) + h / 2 * cos(angle));	whAngle_y3 = (w / 2 * cos(angle) + h / 2 * sin(angle));
		////////////////////////////////////-_-
		switch (direction)	//если едем и вертимся
		{
		case Direction::DOWN: dy = -speed * sin(angle); dx = -speed * cos(angle);

			collisionPoint_X1 = whAngle_x1;  collisionPoint_X2 = whAngle_x2;		////////////(если вниз)
			collisionPoint_Y1 = whAngle_y1;  collisionPoint_Y2 = whAngle_y2; break; ////////////позиции точек для коллизии
																					////////////
		case Direction::UP:	  dy = speed * sin(angle); dx = speed * cos(angle);
																					////////////(если вверх)
			collisionPoint_X1 = whAngle_x2;  collisionPoint_X2 = whAngle_x1;		////////////позиции точек для коллизии
			collisionPoint_Y1 = whAngle_y2;  collisionPoint_Y2 = whAngle_y1; break; ////////////
		}
		if (dy == 0 || dx == 0) { //если вертимся на месте
			switch (rotation) {
			case Rotation::LEFT:
				collisionPoint_X1 = whAngle_x2;  collisionPoint_X2 = whAngle_x2;		////////////(если влево)
				collisionPoint_Y1 = whAngle_y2;  collisionPoint_Y2 = whAngle_y2; break; ////////////позиции точек для коллизии
																						////////////
			case Rotation::RIGHT:
				collisionPoint_X1 = whAngle_x3;  collisionPoint_X2 = whAngle_x3;		////////////(если вправо)
				collisionPoint_Y1 = whAngle_y3;  collisionPoint_Y2 = whAngle_y3; break; ////////////позиции точек для коллизии
			}																			////////////
		}
		x0 = x;
		y0 = y;
		collision = false;
		x += dx * time;//то движение из прошлого урока. наше ускорение на время получаем смещение координат и как следствие движение
		y += dy * time;//аналогично по игреку
		speed = 0;//зануляем скорость, чтобы персонаж остановился.
		sprite.setPosition(x, y); //выводим спрайт в позицию x y , посередине. бесконечно выводим в этой функции, иначе бы наш спрайт стоял на месте.
		sprite.setOrigin(w / 2, h / 2);
		/*
		w = w0 * abs(sin(angle)) + h0 * abs(cos(angle));
		h = w0 * abs(cos(angle)) + h0 * abs(sin(angle));*/
		checkCollisionWithMap();
	}
};

class Enemy :public Entity {
public:
	Enemy(Image& image, Level& lev, float X, float Y, int W, int H, String Name) :Entity(image, X, Y, W, H, Name) {
		if (name == "Sherman") {
			sprite.setTextureRect(IntRect(0, 0, w, h));
			dy = 0.1;//даем скорость.этот объект всегда двигается
		}
	}

	void update(float time)
	{
		if (name == "Sherman") {//для персонажа с таким именем логика будет такой
		//moveTimer += time;if (moveTimer>3000){ dx *= -1; moveTimer = 0; }//меняет направление примерно каждые 3 сек
			speed = 0.15;
			angle = angle - 0.7 * RADS;
			sprite.setOrigin(w / 2, h / 2);
			dy = speed * sin(angle); dx = speed * cos(angle);
			y += dy * time;
			x += dx * time;
			sprite.setRotation(sprite.getRotation() - 0.7);
			sprite.setPosition(x + w/2, y + h/2); //задаем позицию спрайта в место его центра

			if (health <= 0) { life = false; }
		}
	}
};

int main()
{
	Clock clock;
	Image Gun_image;
	Image Body_image;
	Image Enemy_image;
	Level lvl;//создали экземпляр класса уровень
	lvl.LoadFromFile("twolane_blacktop.tmx");//загрузили в него карту, внутри класса с помощью методов он ее обработает.
	
	Object player = lvl.GetObject("Player");
	Object enemy = lvl.GetObject("Enemy");
	Enemy_image.loadFromFile("Images/Sherman.png");
	Gun_image.loadFromFile("Images/tiger2_gun.png");
	Body_image.loadFromFile("Images/tiger2_body.png");

	RenderWindow window(VideoMode(1600, 900), "Game");
	Player Body(Body_image, lvl, player.rect.left, player.rect.top, 65, 125, "Player1");//создаем объект actor класса player,задаем "hero.png" как имя файла+расширение, далее координата Х,У, ширина, высота.
	Player Gun(Gun_image, lvl, player.rect.left, player.rect.top, 45, 215, "Player1");
	Enemy Sherman(Enemy_image, lvl, enemy.rect.left, enemy.rect.top, 50, 140, "Sherman");
	camera.reset(FloatRect(0, 0, 1600, 900));//размер "вида" камеры при создании объекта вида камеры. (потом можем менять как хотим) Что то типа инициализации.
	
	while (window.isOpen())
	{
		float time = clock.getElapsedTime().asMicroseconds();
		clock.restart();
		time = time / 800;
		Event event;
		while (window.pollEvent(event))
		{
			if (event.type == Event::Closed)
				window.close();
		}

		///////////////////////////////////////////Управление персонажем////////////////////////////////////////////////////////////////////////
		Vector2i MousePixelPos = Mouse::getPosition(window);//забираем коорд курсора
		Vector2f MousePos = window.mapPixelToCoords(MousePixelPos);//переводим их в игровые (уходим от коорд окна)
		float dX = MousePos.x - Body.sprite.getPosition().x;//вектор , колинеарный прямой, которая пересекает спрайт и курсор
		float dY = MousePos.y - Body.sprite.getPosition().y;//он же, координата y
		float rotation = (atan2(dY, dX)) * GRADS;//получаем угол в радианах и переводим его в градусы
		Gun.sprite.setOrigin(Gun.sprite.getTextureRect().width / 2, Gun.sprite.getTextureRect().height / 2);
		Gun.sprite.setRotation(rotation + 90);//поворачиваем спрайт на эти градусы

		Body.Control();	//клавиатура
		Body.update(time);		//оживляем объект p класса Player с помощью времени sfml, передавая время в качестве параметра функции update. благодаря этому персонаж может двигаться
		Gun.sprite.setPosition(Body.sprite.getPosition().x, Body.sprite.getPosition().y);

		Sherman.update(time);

		setPlayerCoordinateForCamera(Body.sprite.getPosition().x, Body.sprite.getPosition().y);
		window.setView(camera);	//оживляем камеру в окне sfml
		window.clear(Color(128, 106, 89));

		lvl.Draw(window);
		window.draw(Sherman.sprite);
		window.draw(Body.sprite);
		window.draw(Gun.sprite);
		window.display();
	}
	return 0;
}